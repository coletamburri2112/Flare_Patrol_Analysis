

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>gbm.data.primitives &mdash; GBM Data Tools 1.1.1 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> GBM Data Tools
          

          
            
            <img src="../../../_static/fermi_face.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                1.1.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/index.html">Jupyter Notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">GBM Data Tools API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog/index.html">Change Logs</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">GBM Data Tools</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>gbm.data.primitives</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for gbm.data.primitives</h1><div class="highlight"><pre>
<span></span><span class="c1"># primitives.py: Primitive data classes for pre-binned and unbinned data</span>
<span class="c1">#</span>
<span class="c1">#     Authors: William Cleveland (USRA),</span>
<span class="c1">#              Adam Goldstein (USRA) and</span>
<span class="c1">#              Daniel Kocevski (NASA)</span>
<span class="c1">#</span>
<span class="c1">#     Portions of the code are Copyright 2020 William Cleveland and</span>
<span class="c1">#     Adam Goldstein, Universities Space Research Association</span>
<span class="c1">#     All rights reserved.</span>
<span class="c1">#</span>
<span class="c1">#     Written for the Fermi Gamma-ray Burst Monitor (Fermi-GBM)</span>
<span class="c1">#</span>
<span class="c1">#     This program is free software: you can redistribute it and/or modify</span>
<span class="c1">#     it under the terms of the GNU General Public License as published by</span>
<span class="c1">#     the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1">#     (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1">#     This program is distributed in the hope that it will be useful,</span>
<span class="c1">#     but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1">#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1">#     GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1">#     You should have received a copy of the GNU General Public License</span>
<span class="c1">#     along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<div class="viewcode-block" id="EventList"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.EventList">[docs]</a><span class="k">class</span> <span class="nc">EventList</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A primitive class defining a TTE event list.</span>
<span class="sd">    </span>
<span class="sd">    Attributes:</span>
<span class="sd">        channel_range (int, int): The range of the channels in the list</span>
<span class="sd">        count_spectrum (:class:`EnergyBins`): The count spectrum histogram</span>
<span class="sd">        emax (np.array): The PHA upper energy edges</span>
<span class="sd">        emin (np.array): The PHA lower energy edges</span>
<span class="sd">        energy_range (float, float): The range of the energy edges in the list</span>
<span class="sd">        numchans (int): The number of energy channels. Note that not all </span>
<span class="sd">                        channels will necessarily have events, especially if a </span>
<span class="sd">                        slice is made over energy.</span>
<span class="sd">        pha (np.array): The PHA channel array</span>
<span class="sd">        size (int): The number of events in the list</span>
<span class="sd">        time (np.array): The time array</span>
<span class="sd">        time_range (float, float): The range of the times in the list</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;TIME&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;f8&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;PHA&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;i2&#39;</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ebounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;CHANNEL&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;i2&#39;</span><span class="p">),</span>
                                            <span class="p">(</span><span class="s1">&#39;E_MIN&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;f4&#39;</span><span class="p">),</span>
                                            <span class="p">(</span><span class="s1">&#39;E_MAX&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;f4&#39;</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">_assert_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">valrange</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">valrange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">valrange</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> \
            <span class="s1">&#39;Range must be in increasing order: (lo, hi)&#39;</span>
        <span class="k">return</span> <span class="n">valrange</span>

<div class="viewcode-block" id="EventList.sort"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.EventList.sort">[docs]</a>    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attrib</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;In-place sort by attribute.  Either by &#39;TIME&#39; or &#39;PHA&#39;</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            attrib (str): The name of the EventList attribute, </span>
<span class="sd">                          either &#39;TIME&#39; or &#39;PHA&#39; </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">attrib</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> is not a valid attribute.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">attrib</span><span class="p">)</span> <span class="o">+</span> \
                             <span class="s1">&#39; </span><span class="si">{}</span><span class="s1"> are valid attributes&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">))</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="n">attrib</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_events</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[:][</span><span class="n">idx</span><span class="p">]</span></div>

<div class="viewcode-block" id="EventList.time_slice"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.EventList.time_slice">[docs]</a>    <span class="k">def</span> <span class="nf">time_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform a slice in time of the EventList and return a new EventList</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            tstart (float): The start of the time slice</span>
<span class="sd">            tstop (float): The end of the time slice</span>
<span class="sd">        </span>
<span class="sd">        Returns:        </span>
<span class="sd">            :class:`EventList`:  A new EventList object containing the time slice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">&gt;=</span> <span class="n">tstart</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">&lt;=</span> <span class="n">tstop</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">EventList</span><span class="o">.</span><span class="n">from_fits_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ebounds</span><span class="p">)</span></div>

<div class="viewcode-block" id="EventList.channel_slice"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.EventList.channel_slice">[docs]</a>    <span class="k">def</span> <span class="nf">channel_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chanlo</span><span class="p">,</span> <span class="n">chanhi</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform a slice in energy channels of the EventList and return a </span>
<span class="sd">        new EventList</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            chanlo (int): The start of the channel slice</span>
<span class="sd">            chanhi (int): The end of the channel slice</span>
<span class="sd">        </span>
<span class="sd">        Returns:        </span>
<span class="sd">            :class:`EventList`: A new EventList object containing the channel slice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pha</span> <span class="o">&gt;=</span> <span class="n">chanlo</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pha</span> <span class="o">&lt;=</span> <span class="n">chanhi</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">EventList</span><span class="o">.</span><span class="n">from_fits_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">_ebounds</span><span class="p">)</span></div>

<div class="viewcode-block" id="EventList.energy_slice"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.EventList.energy_slice">[docs]</a>    <span class="k">def</span> <span class="nf">energy_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">emin</span><span class="p">,</span> <span class="n">emax</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform a slice in energy of the EventList and return a new EventList.</span>
<span class="sd">        Since energies are binned, an emin or emax falling inside of an energy</span>
<span class="sd">        channel bin will include that bin in the slice.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            emin (float): The start of the energy slice</span>
<span class="sd">            emax (float): The end of the energy slice</span>
<span class="sd">        </span>
<span class="sd">        Returns:        </span>
<span class="sd">            :class:`EventList`: A new EventList object containing the energy slice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emin</span> <span class="o">&lt;</span> <span class="n">emax</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emax</span> <span class="o">&gt;</span> <span class="n">emin</span><span class="p">)</span>
        <span class="n">ebounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ebounds</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_slice</span><span class="p">(</span><span class="n">ebounds</span><span class="p">[</span><span class="s1">&#39;CHANNEL&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                  <span class="n">ebounds</span><span class="p">[</span><span class="s1">&#39;CHANNEL&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="EventList.bin"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.EventList.bin">[docs]</a>    <span class="k">def</span> <span class="nf">bin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">tstart</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tstop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">event_deadtime</span><span class="o">=</span><span class="mf">2.6e-6</span><span class="p">,</span> <span class="n">overflow_deadtime</span><span class="o">=</span><span class="mf">1.0e-5</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Bin the EventList in time given a binning function and return a</span>
<span class="sd">        2D time-energy channel histogram.  </span>
<span class="sd">        </span>
<span class="sd">        The binning function should take as input an array of times as well</span>
<span class="sd">        as a tstart and tstop keywords for partial list binning.  Additional </span>
<span class="sd">        arguments and keyword arguments specific to the function are allowed.</span>
<span class="sd">        The function should return an array of time edges for the bins, such</span>
<span class="sd">        that, for `n` bins, there are `n` + 1 edges.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            method (&lt;function&gt;): A binning function</span>
<span class="sd">            *args: Arguments to be passed to the binning function</span>
<span class="sd">            tstart (float, optional): </span>
<span class="sd">                If set, defines the start time of the EventList to be binned, </span>
<span class="sd">                otherwise binning will begin at the time of the first event.</span>
<span class="sd">            tstop (float, optional): </span>
<span class="sd">                If set, defines the end time of the EventList to be binned, </span>
<span class="sd">                otherwise binning will end at the time of the last event.</span>
<span class="sd">            event_deadtime (float, optional): The deadtime per event in seconds. </span>
<span class="sd">                                              Default is 2.6e-6.</span>
<span class="sd">            overflow_deadtime (float, optional): </span>
<span class="sd">                The deadtime per event in the overflow channel in seconds. </span>
<span class="sd">                Default is 1e-5.</span>
<span class="sd">            **kwargs: Options to be passed to the binning function</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            :class:`TimeEnergyBins`: A Time-Energy Channel histogram</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tstart</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tstart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">tstop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tstop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># set the start and stop of the rebinning segment        </span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">&gt;=</span> <span class="n">tstart</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">&lt;=</span> <span class="n">tstop</span><span class="p">)</span>
        <span class="n">bin_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;tstart&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tstart</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;tstop&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tstop</span>

        <span class="c1"># get the time edges from the binning function and then do the 2d histo</span>
        <span class="n">time_edges</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="n">bin_times</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span><span class="n">bin_times</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pha</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span>
                                <span class="p">[</span><span class="n">time_edges</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numchans</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># calculate exposure</span>
        <span class="c1"># for gbm, 2.6 microsec per count in channels &lt; 127; </span>
        <span class="c1"># 10 microsec per count for overflow</span>
        <span class="n">lo_edges</span> <span class="o">=</span> <span class="n">time_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">hi_edges</span> <span class="o">=</span> <span class="n">time_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">overflow_counts</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">deadtime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">event_deadtime</span> <span class="o">+</span> \
                   <span class="n">overflow_counts</span> <span class="o">*</span> <span class="p">(</span><span class="n">overflow_deadtime</span> <span class="o">-</span> <span class="n">event_deadtime</span><span class="p">)</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="p">(</span><span class="n">hi_edges</span> <span class="o">-</span> <span class="n">lo_edges</span><span class="p">)</span> <span class="o">-</span> <span class="n">deadtime</span>

        <span class="n">bins</span> <span class="o">=</span> <span class="n">TimeEnergyBins</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">lo_edges</span><span class="p">,</span> <span class="n">hi_edges</span><span class="p">,</span> <span class="n">exposure</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">emin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bins</span></div>

<div class="viewcode-block" id="EventList.rebin_energy"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.EventList.rebin_energy">[docs]</a>    <span class="k">def</span> <span class="nf">rebin_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rebin the PHA channels using the specified binning algorithm.  This</span>
<span class="sd">        does not change the number of events in the EventList, but changes their</span>
<span class="sd">        assignment to a PHA channel and bins the energy bounds mapping to those</span>
<span class="sd">        channels.  A new EventList object is returned.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            method (&lt;function&gt;): A binning function</span>
<span class="sd">            *args: Arguments to be passed to the binning function</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">           :class:`EventList: A new EventList object with the rebinned PHA channels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># exposure and counts; not really used other than for some specific</span>
        <span class="c1"># binning algorithms</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numchans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_exposure</span><span class="p">())</span>
        <span class="n">chans</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pha</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">chans</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numchans</span><span class="p">:</span>
            <span class="n">counts_fill</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numchans</span><span class="p">)</span>
            <span class="n">counts_fill</span><span class="p">[</span><span class="n">chans</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">counts_fill</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numchans</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># call the binning algorithm and get the new edges</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">new_edges</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">exposure</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># re-assign the pha channels based on the new edges</span>
        <span class="c1"># and also rebin the ebounds</span>
        <span class="n">new_pha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pha</span><span class="p">)</span>
        <span class="n">new_ebounds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_edges</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">emin</span> <span class="o">=</span> <span class="n">new_edges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">emax</span> <span class="o">=</span> <span class="n">new_edges</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pha</span> <span class="o">&gt;=</span> <span class="n">emin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pha</span> <span class="o">&lt;</span> <span class="n">emax</span><span class="p">)</span>
            <span class="n">new_pha</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">new_ebounds</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ebounds</span><span class="p">[</span><span class="n">emin</span><span class="p">][</span><span class="s1">&#39;E_MIN&#39;</span><span class="p">],</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_ebounds</span><span class="p">[</span><span class="n">emax</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="s1">&#39;E_MAX&#39;</span><span class="p">]))</span>

        <span class="c1"># create the new EventList object with the rebinned ebounds</span>
        <span class="n">new_events</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span>
        <span class="n">new_events</span><span class="p">[</span><span class="s1">&#39;PHA&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pha</span>
        <span class="n">new_ebounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_ebounds</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;CHANNEL&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;i2&#39;</span><span class="p">),</span>
                                                   <span class="p">(</span><span class="s1">&#39;E_MIN&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;f4&#39;</span><span class="p">),</span>
                                                   <span class="p">(</span><span class="s1">&#39;E_MAX&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;f4&#39;</span><span class="p">)])</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">EventList</span><span class="o">.</span><span class="n">from_fits_array</span><span class="p">(</span><span class="n">new_events</span><span class="p">,</span> <span class="n">new_ebounds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="EventList.get_exposure"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.EventList.get_exposure">[docs]</a>    <span class="k">def</span> <span class="nf">get_exposure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_ranges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">event_deadtime</span><span class="o">=</span><span class="mf">2.6e-6</span><span class="p">,</span>
                     <span class="n">overflow_deadtime</span><span class="o">=</span><span class="mf">1.0e-5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the total exposure of a time range or time ranges of data</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            time_ranges ([(float, float), ...], optional): </span>
<span class="sd">                The time range or time ranges over which to calculate the </span>
<span class="sd">                exposure. If omitted, calculates the total exposure of the data.</span>
<span class="sd">            event_deadtime (float, optional): The deadtime per event in seconds. </span>
<span class="sd">                                              Default is 2.6e-6.</span>
<span class="sd">            overflow_deadtime (float, optional): </span>
<span class="sd">                The deadtime per event in the overflow channel in seconds. </span>
<span class="sd">                Default is 1e-5.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            float: The exposure of the time selections</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">time_ranges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time_ranges</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">time_range</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">time_ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">time_ranges</span> <span class="o">=</span> <span class="p">[</span><span class="n">time_ranges</span><span class="p">]</span>

        <span class="n">exposure</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">time_ranges</span><span class="p">)):</span>
            <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assert_range</span><span class="p">(</span><span class="n">time_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">tcent</span> <span class="o">=</span> <span class="p">(</span><span class="n">tstop</span> <span class="o">+</span> <span class="n">tstart</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">tstop</span> <span class="o">-</span> <span class="n">tstart</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">-</span> <span class="n">tcent</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">dt</span><span class="p">)</span>
            <span class="c1"># mask = (self.time &gt;= tstart) &amp; (self.time &lt; tstop)</span>
            <span class="n">deadtime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">*</span> <span class="n">event_deadtime</span>
            <span class="n">deadtime</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pha</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> \
                        <span class="p">(</span><span class="n">overflow_deadtime</span> <span class="o">-</span> <span class="n">event_deadtime</span><span class="p">)</span>
            <span class="n">exposure</span> <span class="o">+=</span> <span class="p">(</span><span class="n">tstop</span> <span class="o">-</span> <span class="n">tstart</span><span class="p">)</span> <span class="o">-</span> <span class="n">deadtime</span>
        <span class="k">return</span> <span class="n">exposure</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="s1">&#39;TIME&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pha</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="s1">&#39;PHA&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">emin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ebounds</span><span class="p">[</span><span class="s1">&#39;E_MIN&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">emax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ebounds</span><span class="p">[</span><span class="s1">&#39;E_MAX&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">numchans</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ebounds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time_range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">channel_range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pha</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pha</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">energy_range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">emin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ebounds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">min</span><span class="p">()][</span><span class="s1">&#39;E_MIN&#39;</span><span class="p">]</span>
            <span class="n">emax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ebounds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">max</span><span class="p">()][</span><span class="s1">&#39;E_MAX&#39;</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">emin</span><span class="p">,</span> <span class="n">emax</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">count_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pha</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numchans</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numchans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_exposure</span><span class="p">())</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">EnergyBins</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emax</span><span class="p">,</span> <span class="n">exposure</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bins</span>

<div class="viewcode-block" id="EventList.from_fits_array"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.EventList.from_fits_array">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_fits_array</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">events_arr</span><span class="p">,</span> <span class="n">ebounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an EventList object from TTE FITS arrays</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            events_arr (np.recarray or astropy.io.fits.fitsrec.FITS_rec): </span>
<span class="sd">                The TTE events array</span>
<span class="sd">            ebounds (np.recarray or astropy.io.fits.fitsrec.FITS_rec):</span>
<span class="sd">                The TTE Ebounds array, mapping channel numbers to energy bins</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            :class:`EventList`: The new EventList</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">EventList</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_keys</span> <span class="o">=</span> <span class="n">events_arr</span><span class="o">.</span><span class="n">names</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_keys</span> <span class="o">=</span> <span class="n">events_arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_events</span> <span class="o">=</span> <span class="n">events_arr</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_ebounds</span> <span class="o">=</span> <span class="n">ebounds</span>
        <span class="k">return</span> <span class="bp">cls</span></div>

<div class="viewcode-block" id="EventList.from_lists"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.EventList.from_lists">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_lists</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">times_list</span><span class="p">,</span> <span class="n">pha_list</span><span class="p">,</span> <span class="n">chan_lo</span><span class="p">,</span> <span class="n">chan_hi</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an EventList object from lists of times, channels, </span>
<span class="sd">        and the channel bounds. The list of times and channels must be the </span>
<span class="sd">        same length, and the list of channel boundaries are used to map the</span>
<span class="sd">        PHA index number in `pha_list` to energy channels.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            times_list (list of float): A list of event times</span>
<span class="sd">            pha_list (list of int): A list of PHA channels. Must be same length </span>
<span class="sd">                                    as `times_list`.</span>
<span class="sd">            chan_lo (list of float): A list of the lower edges for the energy </span>
<span class="sd">                                     channels.</span>
<span class="sd">            chan_hi (list of float): A list of the upper edges for the energy </span>
<span class="sd">                                     channels. Must be same length as `chan_hi`.</span>
<span class="sd">        Returns:</span>
<span class="sd">            :class:`EventList`: The new EventList</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_events</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">times_list</span><span class="p">)</span>
        <span class="n">num_chans</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chan_lo</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_events</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pha_list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;The length of times_list and pha_list must be the same&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_chans</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chan_hi</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;The length of chan_lo and chan_hi must be the same&#39;</span><span class="p">)</span>

        <span class="c1"># events array</span>
        <span class="n">events_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">times_list</span><span class="p">,</span> <span class="n">pha_list</span><span class="p">))),</span>
                              <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;TIME&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;f8&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;PHA&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;i2&#39;</span><span class="p">)])</span>

        <span class="c1"># ebounds array</span>
        <span class="n">chan_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_chans</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">ebounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">chan_idx</span><span class="p">,</span> <span class="n">chan_lo</span><span class="p">,</span> <span class="n">chan_hi</span><span class="p">))),</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;CHANNEL&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;i2&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;E_MIN&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;f4&#39;</span><span class="p">),</span>
                                  <span class="p">(</span><span class="s1">&#39;E_MAX&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;f4&#39;</span><span class="p">)])</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_fits_array</span><span class="p">(</span><span class="n">events_arr</span><span class="p">,</span> <span class="n">ebounds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="EventList.merge"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.EventList.merge">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">eventlists</span><span class="p">,</span> <span class="n">sort_attrib</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">force_unique</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merge multiple EventLists together in time and optionally sort.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            eventlist (list of :class:`EventList`): </span>
<span class="sd">                A list containing the EventLists to be merged</span>
<span class="sd">            sort_attrib (str, optional): </span>
<span class="sd">                The name of the EventList attribute to sort, either &#39;TIME&#39; or &#39;PHA&#39;</span>
<span class="sd">            force_unique (bool, optional): </span>
<span class="sd">                If True, force all events to be unique via brute force sorting. </span>
<span class="sd">                If False, the EventLists will only be checked and masked for </span>
<span class="sd">                overlapping time ranges. Events can potentially be lost if the </span>
<span class="sd">                merged EventLists contain overlapping times (but not necessarily </span>
<span class="sd">                duplicate events), however this method is much faster.  </span>
<span class="sd">                Default is False.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            :class:`EventList`: A new EventList object containing the merged \</span>
<span class="sd">                                EventLists</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># put in time order</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">eventlist</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="k">for</span> <span class="n">eventlist</span> <span class="ow">in</span> <span class="n">eventlists</span><span class="p">])</span>
        <span class="n">eventlists</span> <span class="o">=</span> <span class="p">[</span><span class="n">eventlists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">]</span>

        <span class="n">new_events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;TIME&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;f8&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;PHA&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;i2&#39;</span><span class="p">)])</span>
        <span class="k">for</span> <span class="n">eventlist</span> <span class="ow">in</span> <span class="n">eventlists</span><span class="p">:</span>
            <span class="c1"># skip empty EventLists</span>
            <span class="k">if</span> <span class="n">eventlist</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># fix for time-shifted data</span>
            <span class="n">ref_time</span> <span class="o">=</span> <span class="n">eventlist</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">temp_events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">eventlist</span><span class="o">.</span><span class="n">_events</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">temp_events</span><span class="p">[</span><span class="s1">&#39;TIME&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ref_time</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">ref_time</span> <span class="o">-</span> <span class="n">temp_events</span><span class="p">[</span><span class="s1">&#39;TIME&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">temp_events</span><span class="p">[</span><span class="s1">&#39;TIME&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">offset</span>

            <span class="c1"># if not forcing to be unique, just make sure there is no time overlap</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">force_unique</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">new_events</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">temp_events</span><span class="p">[</span><span class="s1">&#39;TIME&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">new_events</span><span class="p">[</span><span class="s1">&#39;TIME&#39;</span><span class="p">]))</span>
                <span class="n">temp_events</span> <span class="o">=</span> <span class="n">temp_events</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">new_events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">new_events</span><span class="p">,</span> <span class="n">temp_events</span><span class="p">))</span>

        <span class="c1"># force unique: make sure that we only keep unique events (slower)</span>
        <span class="k">if</span> <span class="n">force_unique</span><span class="p">:</span>
            <span class="n">new_events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">new_events</span><span class="p">)</span>

        <span class="c1"># mark: TODO add check for ebounds consistency</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">EventList</span><span class="o">.</span><span class="n">from_fits_array</span><span class="p">(</span><span class="n">new_events</span><span class="p">,</span> <span class="n">eventlists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_ebounds</span><span class="p">)</span>

        <span class="c1"># do a sort</span>
        <span class="k">if</span> <span class="n">sort_attrib</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sort_attrib</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span></div></div>


<div class="viewcode-block" id="Bins"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.Bins">[docs]</a><span class="k">class</span> <span class="nc">Bins</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A primitive class defining a set of histogram bins</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">        counts (np.array): The array of counts in each bin</span>
<span class="sd">        lo_edges (np.array): The low-value edges of the bins</span>
<span class="sd">        hi_edges (np.array): The high-value edges of the bins</span>

<span class="sd">    Attributes:</span>
<span class="sd">        centroids (np.array): The centroids of the bins</span>
<span class="sd">        counts (np.array): The counts in each bin</span>
<span class="sd">        count_uncertainty (np.array): The count uncertainty in each bin</span>
<span class="sd">        hi_edges (np.array): The high-value edges of the bins</span>
<span class="sd">        lo_edges (np.array): The low-value edges of the bins</span>
<span class="sd">        range (float, float): The range of the bin edges</span>
<span class="sd">        rates (np.array): The count rate of each bin: counts/width</span>
<span class="sd">        rate_uncertainty (np.array): The count rate uncertainty of each bin</span>
<span class="sd">        size (int): Number of bins</span>
<span class="sd">        widths (np.array): The widths of the bins</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">lo_edges</span><span class="p">,</span> <span class="n">hi_edges</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counts</span> <span class="o">=</span> <span class="n">counts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lo_edges</span> <span class="o">=</span> <span class="n">lo_edges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hi_edges</span> <span class="o">=</span> <span class="n">hi_edges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_good_segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_good_segments</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lo_edges</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">counts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counts</span>

    <span class="nd">@counts</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">counts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Bins.counts must be an iterable&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lo_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lo_edges</span>

    <span class="nd">@lo_edges</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">lo_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lo_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Bins.lo_edges must be an iterable&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hi_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hi_edges</span>

    <span class="nd">@hi_edges</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">hi_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hi_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Bins.hi_edges must be an iterable&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">widths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hi_edges</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lo_edges</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">centroids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hi_edges</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lo_edges</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lo_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">hi_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">count_uncertainty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_counts</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">counts</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">widths</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rate_uncertainty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_uncertainty</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span>

<div class="viewcode-block" id="Bins.closest_edge"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.Bins.closest_edge">[docs]</a>    <span class="k">def</span> <span class="nf">closest_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;either&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the closest bin edge</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            val (float): Input value</span>
<span class="sd">            which (str, optional): Options are: </span>
<span class="sd">                </span>
<span class="sd">                * &#39;either&#39; - closest edge to val; </span>
<span class="sd">                * &#39;low&#39; - closest edge lower than val; or </span>
<span class="sd">                * &#39;high&#39; - closest edge higher than val. Default is &#39;either&#39;</span>
<span class="sd">        </span>
<span class="sd">        Returns:        </span>
<span class="sd">            float: The closest bin edge to the input value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">lo_edges</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">hi_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]))</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="n">edges</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;low&#39;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">edges</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;high&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">edges</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">edges</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">edges</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span></div>

<div class="viewcode-block" id="Bins.slice"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.Bins.slice">[docs]</a>    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lo_edge</span><span class="p">,</span> <span class="n">hi_edge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform a slice over the range of the bins and return a new Bins </span>
<span class="sd">        object. Note that lo_edge and hi_edge values that fall inside a bin will</span>
<span class="sd">        result in that bin being included.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            lo_edge (float): The start of the slice</span>
<span class="sd">            hi_edge (float): The end of the slice</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            :class:`Bins`: A new Bins object containing the slice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lo_snap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">closest_edge</span><span class="p">(</span><span class="n">lo_edge</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;low&#39;</span><span class="p">)</span>
        <span class="n">hi_snap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">closest_edge</span><span class="p">(</span><span class="n">hi_edge</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;high&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lo_snap</span> <span class="o">==</span> <span class="n">hi_snap</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lo_edges</span> <span class="o">&lt;</span> <span class="n">hi_snap</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hi_edges</span> <span class="o">&gt;=</span> <span class="n">lo_snap</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lo_edges</span> <span class="o">&lt;</span> <span class="n">hi_snap</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hi_edges</span> <span class="o">&gt;</span> <span class="n">lo_snap</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">Bins</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lo_edges</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">hi_edges</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="Bins.contiguous_bins"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.Bins.contiguous_bins">[docs]</a>    <span class="k">def</span> <span class="nf">contiguous_bins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of Bins, each one containing a continuous segment of </span>
<span class="sd">        data.  This is done by comparing the edges of each bin, and if there</span>
<span class="sd">        is a gap between edges, the data is split into separate Bin objects,</span>
<span class="sd">        each containing a contiguous set of data.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">            list of :class:`Bins`: A list of Bins</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_good_segments</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">bins</span></div>

    <span class="k">def</span> <span class="nf">_calculate_good_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the ranges of data that are contiguous segments</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            [(float, float), ...]: A list of tuples, each containing the edges \</span>
<span class="sd">                                   of a contiguous segment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lo_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hi_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">lo_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">hi_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="bp">self</span><span class="o">.</span><span class="n">lo_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">hi_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">mask</span><span class="p">],</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">lo_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:][</span><span class="n">mask</span><span class="p">],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">hi_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]))</span>
        <span class="n">times</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">times</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span></div>


<div class="viewcode-block" id="TimeBins"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.TimeBins">[docs]</a><span class="k">class</span> <span class="nc">TimeBins</span><span class="p">(</span><span class="n">Bins</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class defining a set of Time History (lightcurve) bins.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        counts (np.array): The array of counts in each bin</span>
<span class="sd">        lo_edges (np.array): The low-value edges of the bins</span>
<span class="sd">        hi_edges (np.array): The high-value edges of the bins</span>
<span class="sd">        exposure (np.array): The exposure of each bin</span>

<span class="sd">    Attributes:</span>
<span class="sd">        centroids (np.array): The centroids of the bins</span>
<span class="sd">        counts (np.array): The counts in each bin</span>
<span class="sd">        count_uncertainty (np.array): The count uncertainty in each bin</span>
<span class="sd">        exposure (np.array): The exposure of each bin</span>
<span class="sd">        hi_edges (np.array): The high-value edges of the bins</span>
<span class="sd">        lo_edges (np.array): The low-value edges of the bins</span>
<span class="sd">        range (float, float): The range of the bin edges</span>
<span class="sd">        rates (np.array): The count rate of each bin: counts/exposure</span>
<span class="sd">        rate_uncertainty (np.array): The count rate uncertainty of each bin</span>
<span class="sd">        size (int): Number of bins</span>
<span class="sd">        widths (np.array): The widths of the bins</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">lo_edges</span><span class="p">,</span> <span class="n">hi_edges</span><span class="p">,</span> <span class="n">exposure</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">lo_edges</span><span class="p">,</span> <span class="n">hi_edges</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exposure</span> <span class="o">=</span> <span class="n">exposure</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">exposure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span>

    <span class="nd">@exposure</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">exposure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_exposure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;TimeBins.exposure must be an iterable&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exposure</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exposure</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">r</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">exposure</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rate_uncertainty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exposure</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exposure</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">r</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_uncertainty</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">exposure</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">r</span>

<div class="viewcode-block" id="TimeBins.from_fits_array"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.TimeBins.from_fits_array">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_fits_array</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an TimeBins object from a FITS counts array</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            arr (np.recarray or astropy.io.fits.fitsrec.FITS_rec): </span>
<span class="sd">                The FITS counts array</span>
<span class="sd">        </span>
<span class="sd">        Returns:        </span>
<span class="sd">            :class:`TimeBins`: The new TimeBins object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
        <span class="k">if</span> <span class="s1">&#39;COUNTS&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keys</span> <span class="ow">or</span> <span class="s1">&#39;TIME&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keys</span> <span class="ow">or</span> \
                <span class="s1">&#39;ENDTIME&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keys</span> <span class="ow">or</span> <span class="s1">&#39;EXPOSURE&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Array has missing or invalid columns&#39;</span><span class="p">)</span>

        <span class="n">counts</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="s1">&#39;COUNTS&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="s1">&#39;COUNTS&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="n">TimeBins</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="s1">&#39;TIME&#39;</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="s1">&#39;ENDTIME&#39;</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="s1">&#39;EXPOSURE&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="TimeBins.slice"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.TimeBins.slice">[docs]</a>    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform a slice over a time range and return a new Bins object. Note </span>
<span class="sd">        that tstart and tstop values that fall inside a bin will result in </span>
<span class="sd">        that bin being included.</span>

<span class="sd">        Args:</span>
<span class="sd">            lo_edge (float): The start of the slice</span>
<span class="sd">            hi_edge (float): The end of the slice</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            :class:`TimeBins`: A new TimeBins object containing the time slice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tstart_snap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">closest_edge</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;low&#39;</span><span class="p">)</span>
        <span class="n">tstop_snap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">closest_edge</span><span class="p">(</span><span class="n">tstop</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;high&#39;</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lo_edges</span> <span class="o">&lt;</span> <span class="n">tstop_snap</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hi_edges</span> <span class="o">&gt;</span> <span class="n">tstart_snap</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lo_edges</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">hi_edges</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">exposure</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="TimeBins.merge"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.TimeBins.merge">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">histos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merge multiple TimeBins together.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            histos (list of :class:`TimeBins`): </span>
<span class="sd">                A list containing the TimeBins to be merged</span>
<span class="sd">        </span>
<span class="sd">        Returns:        </span>
<span class="sd">            :class:`TimeBins`: A new TimeBins object containing the merged TimeBins</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">histos</span><span class="p">)</span>
        <span class="c1"># sort by start time</span>
        <span class="n">tstarts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">histo</span><span class="o">.</span><span class="n">lo_edges</span> <span class="k">for</span> <span class="n">histo</span> <span class="ow">in</span> <span class="n">histos</span><span class="p">])</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">tstarts</span><span class="p">)</span>

        <span class="c1"># concatenate the histos in order</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">counts</span>
        <span class="n">lo_edges</span> <span class="o">=</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">lo_edges</span>
        <span class="n">hi_edges</span> <span class="o">=</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">hi_edges</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">exposure</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
            <span class="n">bin_starts</span> <span class="o">=</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">lo_edges</span>
            <span class="c1"># make sure there is no overlap</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_starts</span> <span class="o">&gt;=</span> <span class="n">hi_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">counts</span><span class="p">,</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
            <span class="n">lo_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span><span class="n">lo_edges</span><span class="p">,</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">lo_edges</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
            <span class="n">hi_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span><span class="n">hi_edges</span><span class="p">,</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">hi_edges</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
            <span class="n">exposure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span><span class="n">exposure</span><span class="p">,</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">exposure</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>

        <span class="c1"># new TimeBins object</span>
        <span class="n">merged_bins</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">lo_edges</span><span class="p">,</span> <span class="n">hi_edges</span><span class="p">,</span> <span class="n">exposure</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">merged_bins</span></div>

<div class="viewcode-block" id="TimeBins.sum"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.TimeBins.sum">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">histos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sum multiple TimeBins together if they have the same time range</span>
<span class="sd">        (support) and the same bin widths.  Example use would be summing</span>
<span class="sd">        two histograms at different energies.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            histos (list of :class:`TimeBins`):  </span>
<span class="sd">                A list containing the TimeBins to be summed</span>
<span class="sd">        </span>
<span class="sd">        Returns:        </span>
<span class="sd">            :class:`TimeBins`: A new TimeBins object containing the summed TimeBins</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">histos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">histo</span> <span class="ow">in</span> <span class="n">histos</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">histo</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">histos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> \
                <span class="s2">&quot;The histograms must all have the same size&quot;</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">histo</span><span class="o">.</span><span class="n">lo_edges</span> <span class="o">==</span> <span class="n">histos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lo_edges</span><span class="p">),</span> \
                <span class="s2">&quot;The histograms must all have the same support&quot;</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">histo</span><span class="o">.</span><span class="n">widths</span> <span class="o">==</span> <span class="n">histos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">widths</span><span class="p">),</span> \
                <span class="s2">&quot;The histograms must all have the same exposure&quot;</span>
            <span class="n">counts</span> <span class="o">+=</span> <span class="n">histo</span><span class="o">.</span><span class="n">counts</span>

        <span class="c1"># averaged exposure</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">histo</span><span class="o">.</span><span class="n">exposure</span> <span class="k">for</span> <span class="n">histo</span> <span class="ow">in</span> <span class="n">histos</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">sum_bins</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">histos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lo_edges</span><span class="p">,</span> <span class="n">histos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">hi_edges</span><span class="p">,</span>
                       <span class="n">exposure</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sum_bins</span></div>

<div class="viewcode-block" id="TimeBins.rebin"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.TimeBins.rebin">[docs]</a>    <span class="k">def</span> <span class="nf">rebin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">tstart</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tstop</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rebin the TimeBins object in given a binning function and return a</span>
<span class="sd">        a new TimeBins object </span>
<span class="sd">        </span>
<span class="sd">        The binning function should take as input an array of counts, </span>
<span class="sd">        array of exposures, and an array of bin edges. Additional arguments </span>
<span class="sd">        specific to the function are allowed. The function should return an </span>
<span class="sd">        array of the new counts, new exposure, and new edges.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            method (&lt;function&gt;): A binning function</span>
<span class="sd">            *args: Arguments to be passed to the binning function</span>
<span class="sd">            tstart (float, optional): </span>
<span class="sd">                If set, defines the start time of the TimeBins to be binned, </span>
<span class="sd">                otherwise binning will begin at the time of the first bin edge.</span>
<span class="sd">            tstop (float, optional): </span>
<span class="sd">                If set, defines the end time of the TimeBins to be binned, </span>
<span class="sd">                otherwise binning will end at the time of the last bin edge.        </span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            :class:`TimeBins`: The rebinned TimeBins object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># set the start and stop of the rebinning segment</span>
        <span class="n">trange</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span>
        <span class="k">if</span> <span class="n">tstart</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tstart</span> <span class="o">=</span> <span class="n">trange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">tstop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tstop</span> <span class="o">=</span> <span class="n">trange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">tstart</span> <span class="o">&lt;</span> <span class="n">trange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">tstart</span> <span class="o">=</span> <span class="n">trange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">tstop</span> <span class="o">&gt;</span> <span class="n">trange</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">tstop</span> <span class="o">=</span> <span class="n">trange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">bins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contiguous_bins</span><span class="p">()</span>
        <span class="n">new_histos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="nb">bin</span> <span class="ow">in</span> <span class="n">bins</span><span class="p">:</span>
            <span class="n">trange</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">range</span>
            <span class="c1"># split the histogram into pieces so that we only rebin the piece</span>
            <span class="c1"># that needs to be rebinned</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">post</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tstop</span> <span class="o">&lt;</span> <span class="n">trange</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">tstart</span> <span class="o">&gt;</span> <span class="n">trange</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">histo</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">tstop</span> <span class="o">==</span> <span class="n">trange</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">tstart</span> <span class="o">&gt;</span> <span class="n">trange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">pre</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">trange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tstart</span><span class="p">)</span>
                <span class="n">histo</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">closest_edge</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;high&#39;</span><span class="p">),</span>
                                  <span class="n">trange</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">tstart</span> <span class="o">==</span> <span class="n">trange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">histo</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">trange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">closest_edge</span><span class="p">(</span><span class="n">tstop</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;low&#39;</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">tstop</span> <span class="o">&lt;</span> <span class="n">trange</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">post</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">tstop</span><span class="p">,</span> <span class="n">trange</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">tstart</span> <span class="o">&gt;</span> <span class="n">trange</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">tstop</span> <span class="o">&lt;</span> <span class="n">trange</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">trange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tstart</span><span class="p">)</span>
                <span class="n">histo</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">closest_edge</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;high&#39;</span><span class="p">),</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">closest_edge</span><span class="p">(</span><span class="n">tstop</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;low&#39;</span><span class="p">))</span>
                <span class="n">post</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">tstop</span><span class="p">,</span> <span class="n">trange</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">histo</span> <span class="o">=</span> <span class="nb">bin</span>
            <span class="c1"># perform the rebinning and create a new histo with the rebinned rates</span>
            <span class="k">if</span> <span class="n">histo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">histo</span><span class="o">.</span><span class="n">lo_edges</span><span class="p">,</span> <span class="n">histo</span><span class="o">.</span><span class="n">hi_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">new_counts</span><span class="p">,</span> <span class="n">new_exposure</span><span class="p">,</span> <span class="n">new_edges</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="n">histo</span><span class="o">.</span><span class="n">counts</span><span class="p">,</span>
                                                             <span class="n">histo</span><span class="o">.</span><span class="n">exposure</span><span class="p">,</span>
                                                             <span class="n">edges</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
                <span class="n">new_histo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_counts</span><span class="p">,</span> <span class="n">new_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                           <span class="n">new_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                                           <span class="n">new_exposure</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_histo</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># now merge the split histo back together again</span>
            <span class="n">histos_to_merge</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">new_histo</span><span class="p">,</span> <span class="n">post</span><span class="p">)</span> <span class="k">if</span>
                               <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">new_histos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">histos_to_merge</span><span class="p">))</span>

        <span class="n">new_histo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">new_histos</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_histo</span></div></div>


<div class="viewcode-block" id="EnergyBins"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.EnergyBins">[docs]</a><span class="k">class</span> <span class="nc">EnergyBins</span><span class="p">(</span><span class="n">TimeBins</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class defining a set of Energy (count spectra) bins.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        counts (np.array): The array of counts in each bin</span>
<span class="sd">        lo_edges (np.array): The low-value edges of the bins</span>
<span class="sd">        hi_edges (np.array): The high-value edges of the bins</span>
<span class="sd">        exposure (np.array): The exposure of each bin</span>

<span class="sd">    Attributes:</span>
<span class="sd">        centroids (np.array): The geometric centroids of the bins</span>
<span class="sd">        counts (np.array): The counts in each bin</span>
<span class="sd">        count_uncertainty (np.array): The count uncertainty in each bin</span>
<span class="sd">        exposure (np.array): The exposure of each bin</span>
<span class="sd">        hi_edges (np.array): The high-value edges of the bins</span>
<span class="sd">        lo_edges (np.array): The low-value edges of the bins</span>
<span class="sd">        range (float, float): The range of the bin edges</span>
<span class="sd">        rates (np.array): The differential count rate of each bin: </span>
<span class="sd">                          counts/(exposure*widths)</span>
<span class="sd">        rate_uncertainty (np.array): The count rate uncertainty of each bin</span>
<span class="sd">        size (int): Number of bins</span>
<span class="sd">        widths (np.array): The widths of the bins</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">lo_edges</span><span class="p">,</span> <span class="n">hi_edges</span><span class="p">,</span> <span class="n">exposure</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">lo_edges</span><span class="p">,</span> <span class="n">hi_edges</span><span class="p">,</span> <span class="n">exposure</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">centroids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hi_edges</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lo_edges</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">counts</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exposure</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">widths</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rate_uncertainty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_uncertainty</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exposure</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">widths</span><span class="p">)</span>

<div class="viewcode-block" id="EnergyBins.from_fits_array"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.EnergyBins.from_fits_array">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_fits_array</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">ebounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an EnergyBins object from a FITS counts array</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            arr (np.recarray or astropy.io.fits.fitsrec.FITS_rec): </span>
<span class="sd">                The FITS counts array</span>
<span class="sd">            ebounds (np.recarray or astropy.io.fits.fitsrec.FITS_rec):</span>
<span class="sd">                The ebounds array, mapping channel numbers to energy bins</span>
<span class="sd">        </span>
<span class="sd">        Returns:        </span>
<span class="sd">            :class:`EnergyBins`: The new EnergyBins object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
        <span class="k">if</span> <span class="s1">&#39;COUNTS&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keys</span> <span class="ow">or</span> <span class="s1">&#39;EXPOSURE&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Array has missing or invalid columns&#39;</span><span class="p">)</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">ebounds</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
        <span class="k">if</span> <span class="s1">&#39;E_MIN&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keys</span> <span class="ow">or</span> <span class="s1">&#39;E_MAX&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;ebounds has missing or invalid columns&#39;</span><span class="p">)</span>

        <span class="n">counts</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="s1">&#39;COUNTS&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="s1">&#39;COUNTS&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">exposure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="s1">&#39;EXPOSURE&#39;</span><span class="p">]))</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="n">EnergyBins</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">ebounds</span><span class="p">[</span><span class="s1">&#39;E_MIN&#39;</span><span class="p">],</span> <span class="n">ebounds</span><span class="p">[</span><span class="s1">&#39;E_MAX&#39;</span><span class="p">],</span> <span class="n">exposure</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="EnergyBins.sum"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.EnergyBins.sum">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">histos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sum multiple EnergyBins together if they have the same energy range</span>
<span class="sd">        (support).  Example use would be summing two count spectra.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            histos (list of :class:`EnergyBins`):  </span>
<span class="sd">                A list containing the EnergyBins to be summed</span>
<span class="sd">        </span>
<span class="sd">        Returns:        </span>
<span class="sd">            :class:`EnergyBins`: A new EnergyBins object containing the \</span>
<span class="sd">                                 summed EnergyBins</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">histos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">histo</span> <span class="ow">in</span> <span class="n">histos</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">histo</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">histos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> \
                <span class="s2">&quot;The histograms must all have the same size&quot;</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">histo</span><span class="o">.</span><span class="n">lo_edges</span> <span class="o">==</span> <span class="n">histos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lo_edges</span><span class="p">),</span> \
                <span class="s2">&quot;The histograms must all have the same support&quot;</span>
            <span class="n">counts</span> <span class="o">+=</span> <span class="n">histo</span><span class="o">.</span><span class="n">counts</span>
            <span class="n">exposure</span> <span class="o">+=</span> <span class="n">histo</span><span class="o">.</span><span class="n">exposure</span>

        <span class="n">sum_bins</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">histos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lo_edges</span><span class="p">,</span> <span class="n">histos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">hi_edges</span><span class="p">,</span>
                       <span class="n">exposure</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sum_bins</span></div>

<div class="viewcode-block" id="EnergyBins.rebin"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.EnergyBins.rebin">[docs]</a>    <span class="k">def</span> <span class="nf">rebin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">emin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">emax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rebin the EnergyBins object in given a binning function and return a</span>
<span class="sd">        a new EnergyBins object </span>

<span class="sd">        The binning function should take as input an array of counts, </span>
<span class="sd">        array of exposures, and an array of bin edges. Additional arguments </span>
<span class="sd">        specific to the function are allowed. The function should return an </span>
<span class="sd">        array of the new counts, new exposure, and new edges.</span>

<span class="sd">        Args:</span>
<span class="sd">            method (&lt;function&gt;): A binning function</span>
<span class="sd">            *args: Arguments to be passed to the binning function</span>
<span class="sd">            emin (float, optional): </span>
<span class="sd">                If set, defines the starting energy of the EnergyBins to be </span>
<span class="sd">                binned, otherwise binning will begin at the first bin edge.</span>
<span class="sd">            emax (float, optional): </span>
<span class="sd">                If set, defines the ending energy of the EnergyBins to be binned, </span>
<span class="sd">                otherwise binning will end at the last bin edge.        </span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            :class:`EnergyBins`: The rebinned EnergyBins object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">histo</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">rebin</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">tstart</span><span class="o">=</span><span class="n">emin</span><span class="p">,</span> <span class="n">tstop</span><span class="o">=</span><span class="n">emax</span><span class="p">)</span>
        <span class="n">histo</span><span class="o">.</span><span class="n">_exposure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exposure</span><span class="p">[:</span><span class="n">histo</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">histo</span></div></div>


<div class="viewcode-block" id="TimeEnergyBins"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.TimeEnergyBins">[docs]</a><span class="k">class</span> <span class="nc">TimeEnergyBins</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;A class defining a set of 2D Time-Energy bins.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        counts (np.array): The array of counts in each bin</span>
<span class="sd">        tstart (np.array): The low-value edges of the time bins</span>
<span class="sd">        tstop (np.array): The high-value edges of the time bins</span>
<span class="sd">        exposure (np.array): The exposure of each bin</span>
<span class="sd">        emin (np.array): The low-value edges of the energy bins</span>
<span class="sd">        emax (np.array): The high-value edges of the energy bins</span>
<span class="sd">    </span>
<span class="sd">    Attributes:</span>
<span class="sd">        chanwidths (np.array): The bin widths along the energy axis</span>
<span class="sd">        count_uncertainty (np.array): The counts uncertainty in each bin</span>
<span class="sd">        energy_centroids (np.array): The bin centroids along the energy axis</span>
<span class="sd">        energy_range (float, float): The range of the data along the energy axis</span>
<span class="sd">        numchans (int): The number of energy channels along the energy axis</span>
<span class="sd">        numtimes (int): The number of bins along the time axis</span>
<span class="sd">        rates (np.array): The rates in each Time-Energy Bin</span>
<span class="sd">        rates_per_kev (np.array): The differential rates in units of counts/s/keV</span>
<span class="sd">        rate_uncertainty (np.array): The rate uncertainty in each bin</span>
<span class="sd">        rate_uncertainty_per_kev (np.array):</span>
<span class="sd">            The differential rate uncertainty in units of counts/s/keV</span>
<span class="sd">        size (int, int): The number of bins along both axes (numtimes, numchans)</span>
<span class="sd">        time_centroids (np.array): The bin centroids along the time axis</span>
<span class="sd">        time_range (float, float): The range of the data along the time axis</span>
<span class="sd">        time_widths (np.array): The bin widths along the time axis</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">,</span> <span class="n">exposure</span><span class="p">,</span> <span class="n">emin</span><span class="p">,</span> <span class="n">emax</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counts</span> <span class="o">=</span> <span class="n">counts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tstart</span> <span class="o">=</span> <span class="n">tstart</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tstop</span> <span class="o">=</span> <span class="n">tstop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exposure</span> <span class="o">=</span> <span class="n">exposure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emin</span> <span class="o">=</span> <span class="n">emin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emax</span> <span class="o">=</span> <span class="n">emax</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numtimes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_good_time_segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_good_segments</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tstop</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_good_time_segments</span> <span class="o">=</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numchans</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_good_energy_segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_good_segments</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">emin</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">emax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_good_energy_segments</span> <span class="o">=</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">numtimes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exposure</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">numchans</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emin</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numtimes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numchans</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time_widths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tstop</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">chan_widths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emax</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">emin</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time_centroids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tstop</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">energy_centroids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emin</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">emax</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time_range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstop</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">energy_range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">emax</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">count_uncertainty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">counts</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exposure</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rate_uncertainty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_uncertainty</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exposure</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rates_per_kev</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rates</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">chan_widths</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rate_uncertainty_per_kev</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate_uncertainty</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">chan_widths</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_assert_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">valrange</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">valrange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">valrange</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> \
            <span class="s1">&#39;Range must be in increasing order: (lo, hi)&#39;</span>
        <span class="k">return</span> <span class="n">valrange</span>

    <span class="k">def</span> <span class="nf">_slice_time_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">):</span>
        <span class="n">tstart_snap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">closest_time_edge</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;low&#39;</span><span class="p">)</span>
        <span class="n">tstop_snap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">closest_time_edge</span><span class="p">(</span><span class="n">tstop</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;high&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tstart_snap</span> <span class="o">==</span> <span class="n">tstop_snap</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tstart</span> <span class="o">&lt;</span> <span class="n">tstop_snap</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tstop</span> <span class="o">&gt;=</span> <span class="n">tstart_snap</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tstart</span> <span class="o">&lt;</span> <span class="n">tstop_snap</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tstop</span> <span class="o">&gt;</span> <span class="n">tstart_snap</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mask</span>

    <span class="k">def</span> <span class="nf">_slice_energy_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">emin</span><span class="p">,</span> <span class="n">emax</span><span class="p">):</span>
        <span class="n">emin_snap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">closest_energy_edge</span><span class="p">(</span><span class="n">emin</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;low&#39;</span><span class="p">)</span>
        <span class="n">emax_snap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">closest_energy_edge</span><span class="p">(</span><span class="n">emax</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;high&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">emin_snap</span> <span class="o">==</span> <span class="n">emax_snap</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emin</span> <span class="o">&lt;</span> <span class="n">emax_snap</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emax</span> <span class="o">&gt;=</span> <span class="n">emin_snap</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emin</span> <span class="o">&lt;</span> <span class="n">emax_snap</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emax</span> <span class="o">&gt;</span> <span class="n">emin_snap</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mask</span>

    <span class="k">def</span> <span class="nf">_calculate_good_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lo_edges</span><span class="p">,</span> <span class="n">hi_edges</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the ranges of data that are contiguous segments</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            lo_edges (np.array): The lower bin edges</span>
<span class="sd">            hi_edges (np.array): The upper bin edges</span>
<span class="sd">        </span>
<span class="sd">        Returns:           </span>
<span class="sd">            [(float, float), ...]: A list of tuples, each containing the edges \</span>
<span class="sd">                                   of a contiguous segment</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">lo_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">hi_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[(</span><span class="n">lo_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hi_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">lo_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">hi_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">mask</span><span class="p">],</span>
                                <span class="n">lo_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:][</span><span class="n">mask</span><span class="p">],</span> <span class="p">[</span><span class="n">hi_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]))</span>
        <span class="n">edges</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">edges</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

<div class="viewcode-block" id="TimeEnergyBins.closest_time_edge"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.TimeEnergyBins.closest_time_edge">[docs]</a>    <span class="k">def</span> <span class="nf">closest_time_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;either&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the closest time bin edge</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            val (float): Input value</span>
<span class="sd">            which (str, optional): Options are: </span>
<span class="sd">                </span>
<span class="sd">                * &#39;either&#39; - closest edge to val; </span>
<span class="sd">                * &#39;low&#39; - closest edge lower than val; </span>
<span class="sd">                * &#39;high&#39; - closest edge higher than val. Default is &#39;either&#39;</span>
<span class="sd">        </span>
<span class="sd">        Returns:           </span>
<span class="sd">            float: The closest time bin edge to the input value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tstop</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]))</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="n">edges</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;low&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;high&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">edges</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">edges</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">edges</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeEnergyBins.closest_energy_edge"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.TimeEnergyBins.closest_energy_edge">[docs]</a>    <span class="k">def</span> <span class="nf">closest_energy_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;either&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the closest energy bin edge</span>

<span class="sd">        Args:</span>
<span class="sd">            val (float): Input value</span>
<span class="sd">            which (str, optional): Options are: </span>
<span class="sd">                </span>
<span class="sd">                * &#39;either&#39; - closest edge to val; </span>
<span class="sd">                * &#39;low&#39; - closest edge lower than val; </span>
<span class="sd">                * &#39;high&#39; - closest edge higher than val. Default is &#39;either&#39;</span>
<span class="sd">        </span>
<span class="sd">        Returns:           </span>
<span class="sd">            float: The closest energy bin edge to the input value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">emin</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">emax</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]))</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="n">edges</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;low&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;high&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">edges</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">edges</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">edges</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeEnergyBins.slice_time"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.TimeEnergyBins.slice_time">[docs]</a>    <span class="k">def</span> <span class="nf">slice_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform a slice over a time range and return a new TimeEnergyBins </span>
<span class="sd">        object. Note that tstart and tstop values that fall inside a bin will </span>
<span class="sd">        result in that bin being included.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            tstart (float): The start of the slice</span>
<span class="sd">            tstop (float): The end of the slice</span>
<span class="sd">        </span>
<span class="sd">        Returns:           </span>
<span class="sd">            :class:`TimeEnergyBins`: A new TimeEnergyBins object containing \</span>
<span class="sd">                                     the time slice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice_time_mask</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">)</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstop</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> 
                  <span class="bp">self</span><span class="o">.</span><span class="n">exposure</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">emin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="TimeEnergyBins.slice_energy"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.TimeEnergyBins.slice_energy">[docs]</a>    <span class="k">def</span> <span class="nf">slice_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">emin</span><span class="p">,</span> <span class="n">emax</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform a slice over an energy range and return a new TimeEnergyBins </span>
<span class="sd">        object. Note that emin and emax values that fall inside a bin will </span>
<span class="sd">        result in that bin being included.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            emin (float): The start of the slice</span>
<span class="sd">            emax (float): The end of the slice</span>
<span class="sd">        </span>
<span class="sd">        Returns:           </span>
<span class="sd">            :class:`TimeEnergyBins`: A new TimeEnergyBins object containing \</span>
<span class="sd">                                    the energy slice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice_energy_mask</span><span class="p">(</span><span class="n">emin</span><span class="p">,</span> <span class="n">emax</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">TimeEnergyBins</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[:,</span> <span class="n">mask</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstop</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">exposure</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emin</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">emax</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="TimeEnergyBins.integrate_energy"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.TimeEnergyBins.integrate_energy">[docs]</a>    <span class="k">def</span> <span class="nf">integrate_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">emin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">emax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Integrate the histogram over the energy axis (producing a lightcurve).</span>
<span class="sd">        Limits on the integration smaller than the full range can be set.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            emin (float, optional): </span>
<span class="sd">                The low end of the integration range. If not set, uses the </span>
<span class="sd">                lowest energy edge of the histogram</span>
<span class="sd">            emax (float, optional): </span>
<span class="sd">                The high end of the integration range. If not set, uses the </span>
<span class="sd">                highest energy edge of the histogram</span>
<span class="sd">        </span>
<span class="sd">        Returns:           </span>
<span class="sd">            :class:`TimeBins`: A TimeBins object containing the lightcurve histogram</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">emin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">emin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">emax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">emax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice_energy_mask</span><span class="p">(</span><span class="n">emin</span><span class="p">,</span> <span class="n">emax</span><span class="p">)</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[:,</span> <span class="n">mask</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="n">TimeBins</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exposure</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="TimeEnergyBins.integrate_time"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.TimeEnergyBins.integrate_time">[docs]</a>    <span class="k">def</span> <span class="nf">integrate_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tstart</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tstop</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Integrate the histogram over the time axis (producing a count rate</span>
<span class="sd">        spectrum). Limits on the integration smaller than the full range can </span>
<span class="sd">        be set.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            tstart (float, optional): </span>
<span class="sd">                The low end of the integration range. If not set, uses the </span>
<span class="sd">                lowest time edge of the histogram</span>
<span class="sd">            tstop (float, optional): </span>
<span class="sd">                The high end of the integration range. If not set, uses the </span>
<span class="sd">                highest time edge of the histogram</span>
<span class="sd">        </span>
<span class="sd">        Returns:           </span>
<span class="sd">            :class:`EnergyBins`: A EnergyBins object containing the count \</span>
<span class="sd">                                 rate spectrum histogram</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tstart</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tstart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">tstop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tstop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice_time_mask</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">)</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exposure</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">exposure</span><span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="n">EnergyBins</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emax</span><span class="p">,</span> <span class="n">exposure</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="TimeEnergyBins.contiguous_time_bins"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.TimeEnergyBins.contiguous_time_bins">[docs]</a>    <span class="k">def</span> <span class="nf">contiguous_time_bins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of TimeEnergyBins, each one containing a contiguous</span>
<span class="sd">        time segment of data.  This is done by comparing the edges of each time</span>
<span class="sd">        bin, and if thereis a gap between edges, the data is split into </span>
<span class="sd">        separate TimeEnergyBin objects, each containing a time-contiguous set </span>
<span class="sd">        of data.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list of :class:`TimeEnergyBins`: A list of TimeEnergyBins</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">slice_time</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_good_time_segments</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">bins</span></div>

<div class="viewcode-block" id="TimeEnergyBins.contiguous_energy_bins"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.TimeEnergyBins.contiguous_energy_bins">[docs]</a>    <span class="k">def</span> <span class="nf">contiguous_energy_bins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of TimeEnergyBins, each one containing a contiguous</span>
<span class="sd">        energy segment of data.  This is done by comparing the edges of each</span>
<span class="sd">        energy bin, and if thereis a gap between edges, the data is split into </span>
<span class="sd">        separate TimeEnergyBin objects, each containing an energy-contiguous set </span>
<span class="sd">        of data.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list of :class:`TimeEnergyBins`: A list of TimeEnergyBins</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">slice_energy</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_good_energy_segments</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">bins</span></div>

<div class="viewcode-block" id="TimeEnergyBins.rebin_time"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.TimeEnergyBins.rebin_time">[docs]</a>    <span class="k">def</span> <span class="nf">rebin_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">tstart</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tstop</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rebin the TimeEnergyBins object along the time axis given a binning </span>
<span class="sd">        function and return a new TimeEnergyBins object </span>
<span class="sd">        </span>
<span class="sd">        The binning function should take as input an array of counts, </span>
<span class="sd">        array of exposures, and an array of bin edges. Additional arguments </span>
<span class="sd">        specific to the function are allowed. The function should return an </span>
<span class="sd">        array of the new counts, new exposure, and new edges.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            method (&lt;function&gt;): A binning function</span>
<span class="sd">            *args:  Arguments to be passed to the binning function</span>
<span class="sd">            tstart (float, optional): </span>
<span class="sd">                If set, defines the start time of the TimeEnergyBins to be </span>
<span class="sd">                binned, otherwise binning will begin at the time of the first </span>
<span class="sd">                bin edge.</span>
<span class="sd">            tstop (float, optional): </span>
<span class="sd">                If set, defines the end time of the TimeEnergyBins to be </span>
<span class="sd">                binned, otherwise binning will end at the time of the last </span>
<span class="sd">                bin edge.</span>
<span class="sd">        </span>
<span class="sd">        Returns:       </span>
<span class="sd">            :class:`TimeEnergyBins`: The rebinned TimeEnergyBins object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># set the start and stop of the rebinning segment</span>
        <span class="n">trange</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_range</span>
        <span class="k">if</span> <span class="n">tstart</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tstart</span> <span class="o">=</span> <span class="n">trange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">tstop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tstop</span> <span class="o">=</span> <span class="n">trange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">tstart</span> <span class="o">&lt;</span> <span class="n">trange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">tstart</span> <span class="o">=</span> <span class="n">trange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">tstop</span> <span class="o">&gt;</span> <span class="n">trange</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">tstop</span> <span class="o">=</span> <span class="n">trange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">bins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contiguous_time_bins</span><span class="p">()</span>
        <span class="n">new_histos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="nb">bin</span> <span class="ow">in</span> <span class="n">bins</span><span class="p">:</span>
            <span class="n">trange</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">time_range</span>
            <span class="c1"># split the histogram into pieces so that we only rebin the piece</span>
            <span class="c1"># that needs to be rebinned</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">post</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tstop</span> <span class="o">&lt;</span> <span class="n">trange</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">tstart</span> <span class="o">&gt;</span> <span class="n">trange</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">histo</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">tstop</span> <span class="o">==</span> <span class="n">trange</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">tstart</span> <span class="o">&gt;</span> <span class="n">trange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">pre</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">slice_time</span><span class="p">(</span><span class="n">trange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tstart</span><span class="p">)</span>
                <span class="n">histo</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">slice_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">closest_time_edge</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span>
                                                              <span class="n">which</span><span class="o">=</span><span class="s1">&#39;high&#39;</span><span class="p">),</span>
                                       <span class="n">trange</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">tstart</span> <span class="o">==</span> <span class="n">trange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">histo</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">slice_time</span><span class="p">(</span><span class="n">trange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">closest_time_edge</span><span class="p">(</span><span class="n">tstop</span><span class="p">,</span>
                                                              <span class="n">which</span><span class="o">=</span><span class="s1">&#39;low&#39;</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">tstop</span> <span class="o">&lt;</span> <span class="n">trange</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">post</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">slice_time</span><span class="p">(</span><span class="n">tstop</span><span class="p">,</span> <span class="n">trange</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">tstart</span> <span class="o">&gt;</span> <span class="n">trange</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">tstop</span> <span class="o">&lt;</span> <span class="n">trange</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">slice_time</span><span class="p">(</span><span class="n">trange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tstart</span><span class="p">)</span>
                <span class="n">histo</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">slice_time</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">closest_time_edge</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;high&#39;</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">closest_time_edge</span><span class="p">(</span><span class="n">tstop</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;low&#39;</span><span class="p">))</span>
                <span class="n">post</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">slice_time</span><span class="p">(</span><span class="n">tstop</span><span class="p">,</span> <span class="n">trange</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">histo</span> <span class="o">=</span> <span class="nb">bin</span>
            <span class="c1"># perform the rebinning and create a new histo with the rebinned rates</span>
            <span class="k">if</span> <span class="n">histo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">histo</span><span class="o">.</span><span class="n">tstart</span><span class="p">,</span> <span class="n">histo</span><span class="o">.</span><span class="n">tstop</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">new_counts</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">bin</span><span class="o">.</span><span class="n">numchans</span><span class="p">):</span>
                    <span class="n">new_cts</span><span class="p">,</span> <span class="n">new_exposure</span><span class="p">,</span> <span class="n">new_edges</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span>
                        <span class="n">histo</span><span class="o">.</span><span class="n">counts</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span>
                        <span class="n">histo</span><span class="o">.</span><span class="n">exposure</span><span class="p">,</span>
                        <span class="n">edges</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
                    <span class="n">new_counts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_cts</span><span class="p">)</span>
                <span class="n">new_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_counts</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

                <span class="n">new_histo</span> <span class="o">=</span> <span class="n">TimeEnergyBins</span><span class="p">(</span><span class="n">new_counts</span><span class="p">,</span> <span class="n">new_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                           <span class="n">new_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                                           <span class="n">new_exposure</span><span class="p">,</span> <span class="nb">bin</span><span class="o">.</span><span class="n">emin</span><span class="p">,</span> <span class="nb">bin</span><span class="o">.</span><span class="n">emax</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_histo</span> <span class="o">=</span> <span class="nb">bin</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_histo</span><span class="o">.</span><span class="n">tstart</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">new_histo</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># now merge the split histo back together again</span>
            <span class="n">histos_to_merge</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">new_histo</span><span class="p">,</span> <span class="n">post</span><span class="p">)</span> <span class="k">if</span>
                               <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">new_histos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">TimeEnergyBins</span><span class="o">.</span><span class="n">merge_time</span><span class="p">(</span><span class="n">histos_to_merge</span><span class="p">))</span>

        <span class="n">new_histo</span> <span class="o">=</span> <span class="n">TimeEnergyBins</span><span class="o">.</span><span class="n">merge_time</span><span class="p">(</span><span class="n">new_histos</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_histo</span></div>

<div class="viewcode-block" id="TimeEnergyBins.rebin_energy"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.TimeEnergyBins.rebin_energy">[docs]</a>    <span class="k">def</span> <span class="nf">rebin_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">emin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">emax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rebin the TimeEnergyBins object along the energy axis given a binning </span>
<span class="sd">        function and return a new TimeEnergyBins object </span>
<span class="sd">        </span>
<span class="sd">        The binning function should take as input an array of counts, </span>
<span class="sd">        array of exposures, and an array of bin edges. Additional arguments </span>
<span class="sd">        specific to the function are allowed. The function should return an </span>
<span class="sd">        array of the new counts, new exposure, and new edges.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            method (&lt;function&gt;):  A binning function</span>
<span class="sd">            *args:  Arguments to be passed to the binning function</span>
<span class="sd">            emin (float, optional): </span>
<span class="sd">                If set, defines the starting edge of the TimeEnergyBins to be </span>
<span class="sd">                binned, otherwise binning will begin at the the first bin edge.</span>
<span class="sd">            emax (float, optional): </span>
<span class="sd">                If set, defines the ending edge of the TimeEnergyBins to be </span>
<span class="sd">                binned, otherwise binning will end at the last bin edge.</span>
<span class="sd">        </span>
<span class="sd">        Returns:        </span>
<span class="sd">            :class:`TimeEnergyBins`: The rebinned TimeEnergyBins object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># set the start and stop of the rebinning segment</span>
        <span class="n">erange</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy_range</span>
        <span class="k">if</span> <span class="n">emin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">emin</span> <span class="o">=</span> <span class="n">erange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">emax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">emax</span> <span class="o">=</span> <span class="n">erange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">emin</span> <span class="o">&lt;</span> <span class="n">erange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">emin</span> <span class="o">=</span> <span class="n">erange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">emax</span> <span class="o">&gt;</span> <span class="n">erange</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">emax</span> <span class="o">=</span> <span class="n">erange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">bins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contiguous_energy_bins</span><span class="p">()</span>
        <span class="n">new_histos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="nb">bin</span> <span class="ow">in</span> <span class="n">bins</span><span class="p">:</span>
            <span class="c1"># split the histogram into pieces so that we only rebin the piece</span>
            <span class="c1"># that needs to be rebinned</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">post</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">emax</span> <span class="o">&lt;</span> <span class="n">erange</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">emin</span> <span class="o">&gt;</span> <span class="n">erange</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">histo</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">emax</span> <span class="o">==</span> <span class="n">erange</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">emin</span> <span class="o">&gt;</span> <span class="n">erange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">pre</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">slice_energy</span><span class="p">(</span><span class="n">erange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">emin</span><span class="p">)</span>
                <span class="n">histo</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">slice_energy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">closest_energy_edge</span><span class="p">(</span><span class="n">emin</span><span class="p">,</span>
                                                                  <span class="n">which</span><span class="o">=</span><span class="s1">&#39;high&#39;</span><span class="p">),</span>
                                         <span class="n">erange</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">emin</span> <span class="o">==</span> <span class="n">erange</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">histo</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">slice_energy</span><span class="p">(</span><span class="n">erange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">closest_energy_edge</span><span class="p">(</span><span class="n">emax</span><span class="p">,</span>
                                                                  <span class="n">which</span><span class="o">=</span><span class="s1">&#39;low&#39;</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">emax</span> <span class="o">&lt;</span> <span class="n">erange</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">post</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">slice_energy</span><span class="p">(</span><span class="n">emax</span><span class="p">,</span> <span class="n">erange</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">emin</span> <span class="o">&gt;</span> <span class="n">erange</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">emax</span> <span class="o">&lt;</span> <span class="n">erange</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">slice_energy</span><span class="p">(</span><span class="n">erange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">emin</span><span class="p">)</span>
                <span class="n">histo</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">slice_energy</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">closest_energy_edge</span><span class="p">(</span><span class="n">emin</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;high&#39;</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">closest_energy_edge</span><span class="p">(</span><span class="n">emax</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;low&#39;</span><span class="p">))</span>
                <span class="n">post</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">slice_energy</span><span class="p">(</span><span class="n">emax</span><span class="p">,</span> <span class="n">erange</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">histo</span> <span class="o">=</span> <span class="nb">bin</span>
                <span class="c1"># perform the rebinning and create a new histo with the rebinned rates</span>
            <span class="k">if</span> <span class="n">histo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">histo</span><span class="o">.</span><span class="n">emin</span><span class="p">,</span> <span class="n">histo</span><span class="o">.</span><span class="n">emax</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">numtimes</span><span class="p">,</span> <span class="n">numchans</span> <span class="o">=</span> <span class="n">histo</span><span class="o">.</span><span class="n">size</span>
                <span class="n">new_counts</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numtimes</span><span class="p">):</span>
                    <span class="n">exposure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">numchans</span><span class="p">,</span> <span class="n">histo</span><span class="o">.</span><span class="n">exposure</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">new_cts</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">new_edges</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="n">histo</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span>
                                                   <span class="n">exposure</span><span class="p">,</span>
                                                   <span class="n">edges</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
                    <span class="n">new_counts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_cts</span><span class="p">)</span>
                <span class="n">new_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_counts</span><span class="p">)</span>
                <span class="n">new_histo</span> <span class="o">=</span> <span class="n">TimeEnergyBins</span><span class="p">(</span><span class="n">new_counts</span><span class="p">,</span> <span class="nb">bin</span><span class="o">.</span><span class="n">tstart</span><span class="p">,</span> <span class="nb">bin</span><span class="o">.</span><span class="n">tstop</span><span class="p">,</span>
                                           <span class="nb">bin</span><span class="o">.</span><span class="n">exposure</span><span class="p">,</span> <span class="n">new_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                           <span class="n">new_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_histo</span> <span class="o">=</span> <span class="nb">bin</span>

            <span class="c1"># now merge the split histo back together again</span>
            <span class="n">histos_to_merge</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">new_histo</span><span class="p">,</span> <span class="n">post</span><span class="p">)</span> <span class="k">if</span>
                               <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">new_histos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">TimeEnergyBins</span><span class="o">.</span><span class="n">merge_energy</span><span class="p">(</span><span class="n">histos_to_merge</span><span class="p">))</span>

        <span class="n">new_histo</span> <span class="o">=</span> <span class="n">TimeEnergyBins</span><span class="o">.</span><span class="n">merge_energy</span><span class="p">(</span><span class="n">new_histos</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_histo</span></div>

<div class="viewcode-block" id="TimeEnergyBins.get_exposure"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.TimeEnergyBins.get_exposure">[docs]</a>    <span class="k">def</span> <span class="nf">get_exposure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_ranges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the total exposure of a time range or time ranges of data</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            time_ranges ([(float, float), ...], optional): </span>
<span class="sd">                The time range or time ranges over which to calculate the </span>
<span class="sd">                exposure. If omitted, calculates the total exposure of the data        </span>
<span class="sd">            scale (bool, optional): </span>
<span class="sd">                If True and the time ranges don&#39;t match up with the data binning, </span>
<span class="sd">                will scale the exposure based on the requested time range. </span>
<span class="sd">                Default is False.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            float: The exposure of the time selections</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">time_ranges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time_ranges</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">time_range</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">time_ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">time_ranges</span> <span class="o">=</span> <span class="p">[</span><span class="n">time_ranges</span><span class="p">]</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">time_ranges</span><span class="p">)):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice_time_mask</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_assert_range</span><span class="p">(</span><span class="n">time_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">time_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">time_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">data_exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exposure</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
            <span class="n">dts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tstop</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">dts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">scale</span><span class="p">:</span>
                    <span class="n">exposure</span> <span class="o">+=</span> <span class="n">data_exp</span> <span class="o">*</span> <span class="p">(</span><span class="n">dt</span> <span class="o">/</span> <span class="n">ds</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">exposure</span> <span class="o">+=</span> <span class="n">data_exp</span>

        <span class="k">return</span> <span class="n">exposure</span></div>

<div class="viewcode-block" id="TimeEnergyBins.merge_time"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.TimeEnergyBins.merge_time">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">merge_time</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">histos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merge multiple TimeEnergyBins together along the time axis.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            histos (list of :class:`TimeEnergyBins`): </span>
<span class="sd">                A list containing the TimeEnergyBins to be merged</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">            :class:`TimeEnergyBins`: A new TimEnergyBins object containing the \</span>
<span class="sd">                                     merged TimeEnergyBins</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">histos</span><span class="p">)</span>
        <span class="c1"># sort by start time</span>
        <span class="n">tstarts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">histo</span><span class="o">.</span><span class="n">tstart</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">histo</span> <span class="ow">in</span> <span class="n">histos</span><span class="p">])</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">tstarts</span><span class="p">)</span>

        <span class="c1"># concatenate the histos in order</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">counts</span>
        <span class="n">tstart</span> <span class="o">=</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">tstart</span>
        <span class="n">tstop</span> <span class="o">=</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">tstop</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">exposure</span>
        <span class="n">emin</span> <span class="o">=</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">emin</span>
        <span class="n">emax</span> <span class="o">=</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">emax</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
            <span class="n">bin_starts</span> <span class="o">=</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">tstart</span>
            <span class="c1"># make sure there is no overlap</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_starts</span> <span class="o">&gt;=</span> <span class="n">tstop</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">counts</span><span class="p">,</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]))</span>
            <span class="n">tstart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">tstart</span><span class="p">,</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">tstart</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
            <span class="n">tstop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">tstop</span><span class="p">,</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">tstop</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
            <span class="n">exposure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span><span class="n">exposure</span><span class="p">,</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">exposure</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>

        <span class="c1"># new TimeEnergyBins object</span>
        <span class="n">merged_bins</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">,</span> <span class="n">exposure</span><span class="p">,</span> <span class="n">emin</span><span class="p">,</span> <span class="n">emax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">merged_bins</span></div>

<div class="viewcode-block" id="TimeEnergyBins.merge_energy"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.TimeEnergyBins.merge_energy">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">merge_energy</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">histos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merge multiple TimeEnergyBins together along the energy axis.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            histos (list of :class:`TimeEnergyBins`): </span>
<span class="sd">                A list containing the TimeEnergyBins to be merged</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            :class:`TimeEnergyBins`: A new TimEnergyBins object containing \</span>
<span class="sd">                                     the merged TimeEnergyBins</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">histos</span><span class="p">)</span>
        <span class="c1"># sort by channel edge</span>
        <span class="n">emins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">histo</span><span class="o">.</span><span class="n">emin</span> <span class="k">for</span> <span class="n">histo</span> <span class="ow">in</span> <span class="n">histos</span><span class="p">])</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">emins</span><span class="p">)</span>

        <span class="c1"># concatenate the histos in order</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">counts</span>
        <span class="n">tstart</span> <span class="o">=</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">tstart</span>
        <span class="n">tstop</span> <span class="o">=</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">tstop</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">exposure</span>
        <span class="n">emin</span> <span class="o">=</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">emin</span>
        <span class="n">emax</span> <span class="o">=</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">emax</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
            <span class="n">bin_starts</span> <span class="o">=</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">emin</span>
            <span class="c1"># make sure there is no overlap</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_starts</span> <span class="o">&gt;=</span> <span class="n">emax</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">counts</span><span class="p">,</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">counts</span><span class="p">[:,</span> <span class="n">mask</span><span class="p">]))</span>
            <span class="n">emin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">emin</span><span class="p">,</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">emin</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
            <span class="n">emax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">emax</span><span class="p">,</span> <span class="n">histos</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">emax</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>

        <span class="c1"># new TimeEnergyBins object</span>
        <span class="n">merged_bins</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">,</span> <span class="n">exposure</span><span class="p">,</span> <span class="n">emin</span><span class="p">,</span> <span class="n">emax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">merged_bins</span></div></div>


<div class="viewcode-block" id="TimeRange"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.TimeRange">[docs]</a><span class="k">class</span> <span class="nc">TimeRange</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;A primitive class defining a time range</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">        tstart (float): The start time of the range</span>
<span class="sd">        tstop (float): The end time of the range</span>

<span class="sd">    Attributes:</span>
<span class="sd">        center (float): The center of the time range</span>
<span class="sd">        duration (float): The duration of the time range</span>
<span class="sd">        tstart (float): The start time of the range</span>
<span class="sd">        tstop (float): The end time of the range</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">):</span>
        <span class="n">tstart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assert_time</span><span class="p">(</span><span class="n">tstart</span><span class="p">)</span>
        <span class="n">tstop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assert_time</span><span class="p">(</span><span class="n">tstop</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tstop</span> <span class="o">&gt;=</span> <span class="n">tstart</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tstart</span> <span class="o">=</span> <span class="n">tstart</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tstop</span> <span class="o">=</span> <span class="n">tstop</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tstart</span> <span class="o">=</span> <span class="n">tstop</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tstop</span> <span class="o">=</span> <span class="n">tstart</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;(</span><span class="si">{0}</span><span class="s1">, </span><span class="si">{1}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstop</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_assert_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atime</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">atime</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">atime</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;time must be a float&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">atime</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tstart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tstart</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tstop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tstop</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">duration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstop</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstart</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tstart</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstop</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

<div class="viewcode-block" id="TimeRange.as_tuple"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.TimeRange.as_tuple">[docs]</a>    <span class="k">def</span> <span class="nf">as_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the time range as a tuple.</span>
<span class="sd">        </span>
<span class="sd">        Returns:  </span>
<span class="sd">            (float, float): The starting and ending time of the time range</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstop</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeRange.contains"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.TimeRange.contains">[docs]</a>    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a_time</span><span class="p">,</span> <span class="n">inclusive</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine if the time range contains a time.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            a_time (float): The input time to check</span>
<span class="sd">            inclusive (bool, optional): </span>
<span class="sd">                If True, then includes the edges of the range for the check, </span>
<span class="sd">                otherwise it is edge-exclusive. Default is True.</span>
<span class="sd">        </span>
<span class="sd">        Returns:           </span>
<span class="sd">            bool: True if the time is in the time range, False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assert_time</span><span class="p">(</span><span class="n">a_time</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inclusive</span><span class="p">:</span>
            <span class="n">test</span> <span class="o">=</span> <span class="p">(</span><span class="n">a_time</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstop</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">a_time</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">test</span> <span class="o">=</span> <span class="p">(</span><span class="n">a_time</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstop</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">a_time</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstart</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">test</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="TimeRange.union"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.TimeRange.union">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">range1</span><span class="p">,</span> <span class="n">range2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new TimeRange that is the union of two input TimeRanges</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            range1 (:class:`TimeRange`): A time range used to calculate the union</span>
<span class="sd">            range2 (:class:`TimeRange`): Another time range used to calculate </span>
<span class="sd">                                         the union</span>
<span class="sd">        </span>
<span class="sd">        Returns:           </span>
<span class="sd">            :class:`TimeRange`: The unionized time range</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tstart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="n">range1</span><span class="o">.</span><span class="n">tstart</span><span class="p">,</span> <span class="n">range2</span><span class="o">.</span><span class="n">tstart</span><span class="p">))</span>
        <span class="n">tstop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="n">range1</span><span class="o">.</span><span class="n">tstop</span><span class="p">,</span> <span class="n">range2</span><span class="o">.</span><span class="n">tstop</span><span class="p">))</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="TimeRange.intersection"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.TimeRange.intersection">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">range1</span><span class="p">,</span> <span class="n">range2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new TimeRange that is the intersection of two input </span>
<span class="sd">        TimeRanges.  If the input TimeRanges do not intersect, then None is </span>
<span class="sd">        returned.</span>

<span class="sd">        Args:</span>
<span class="sd">            range1 (:class:`TimeRange`): A time range used to calculate the </span>
<span class="sd">                                         intersection</span>
<span class="sd">            range2 (:class:`TimeRange`): Another time range used to calculate </span>
<span class="sd">                                         the intersection</span>
<span class="sd">        </span>
<span class="sd">        Returns:           </span>
<span class="sd">            :class:`TimeRange`: The intersected time range</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># test if one tstart is inside the other time range</span>
        <span class="k">if</span> <span class="n">range1</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">range2</span><span class="o">.</span><span class="n">tstart</span><span class="p">):</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="n">range1</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="n">range2</span>
        <span class="k">elif</span> <span class="n">range2</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">range1</span><span class="o">.</span><span class="n">tstart</span><span class="p">):</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="n">range2</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="n">range1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># do the merge</span>
        <span class="n">tstart</span> <span class="o">=</span> <span class="n">upper</span><span class="o">.</span><span class="n">tstart</span>
        <span class="n">tstop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="n">lower</span><span class="o">.</span><span class="n">tstop</span><span class="p">,</span> <span class="n">upper</span><span class="o">.</span><span class="n">tstop</span><span class="p">))</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span></div></div>


<div class="viewcode-block" id="GTI"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.GTI">[docs]</a><span class="k">class</span> <span class="nc">GTI</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A primitive class defining a set of Good Time Intervals (GTIs)</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">        tstart (float): The start time of the GTI</span>
<span class="sd">        tstop (float): The end time of the GTI</span>
<span class="sd">        </span>
<span class="sd">    Attributes:</span>
<span class="sd">        num_intervals (int): The number of intervals in the GTI</span>
<span class="sd">        range (float, float): The full range of the GTI</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tstart</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tstop</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gti</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tstart</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">tstop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gti</span> <span class="o">=</span> <span class="p">[</span><span class="n">TimeRange</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">)]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gti</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The full range of the GTI</span>
<span class="sd">        </span>
<span class="sd">        :type: (float, float)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gti</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tstart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gti</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">tstop</span><span class="p">)</span>

<div class="viewcode-block" id="GTI.as_list"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.GTI.as_list">[docs]</a>    <span class="k">def</span> <span class="nf">as_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the GTI as a list of tuples.</span>
<span class="sd">        </span>
<span class="sd">        Returns:     </span>
<span class="sd">            [(float, float), ...]: The list of GTI interval tuples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gti_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">one_gti</span><span class="o">.</span><span class="n">as_tuple</span><span class="p">()</span> <span class="k">for</span> <span class="n">one_gti</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gti</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">gti_list</span></div>

<div class="viewcode-block" id="GTI.insert"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.GTI.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Insert a new interval into the GTI</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            tstart (float): The start time of the new interval</span>
<span class="sd">            tstop (float): The end time of the new interval</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># where the new time range should be inserted</span>
        <span class="n">time_range</span> <span class="o">=</span> <span class="n">TimeRange</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tstop</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gti</span><span class="p">)</span> <span class="k">if</span>
               <span class="n">j</span><span class="o">.</span><span class="n">tstart</span> <span class="o">&lt;=</span> <span class="n">time_range</span><span class="o">.</span><span class="n">tstart</span><span class="p">]</span>

        <span class="c1"># determine if there is overlap with the lower bounding range, and if so</span>
        <span class="c1"># then merge</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gti</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">time_range</span><span class="o">.</span><span class="n">tstart</span><span class="p">,</span> <span class="n">inclusive</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="n">the_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gti</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="n">time_range</span> <span class="o">=</span> <span class="n">TimeRange</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">the_range</span><span class="p">,</span> <span class="n">time_range</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># determine if there is overlap with the upper bounding range, and if so</span>
        <span class="c1"># then merge</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gti</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gti</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">time_range</span><span class="o">.</span><span class="n">tstop</span><span class="p">):</span>
                <span class="n">the_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gti</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="n">time_range</span> <span class="o">=</span> <span class="n">TimeRange</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">the_range</span><span class="p">,</span> <span class="n">time_range</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_gti</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">time_range</span><span class="p">)</span></div>

<div class="viewcode-block" id="GTI.contains"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.GTI.contains">[docs]</a>    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a_time</span><span class="p">,</span> <span class="n">inclusive</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine if the GTI contains a time.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            a_time (float): The input time to check</span>
<span class="sd">            inclusive (bool, optional): </span>
<span class="sd">                If True, then includes the edges of the range for the check, </span>
<span class="sd">                otherwise it is edge-exclusive. Default is True.</span>
<span class="sd">        </span>
<span class="sd">        Returns:           </span>
<span class="sd">            bool: True if the time is in the GTI, False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">test</span> <span class="o">=</span> <span class="p">[</span><span class="n">gti</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">a_time</span><span class="p">,</span> <span class="n">inclusive</span><span class="o">=</span><span class="n">inclusive</span><span class="p">)</span> <span class="k">for</span> <span class="n">gti</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gti</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">test</span><span class="p">)</span></div>

<div class="viewcode-block" id="GTI.from_list"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.GTI.from_list">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_list</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">gti_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new GTI object from a list of tuples.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            gti_list ([(float, float), ...]):  A list of interval tuples</span>
<span class="sd">        </span>
<span class="sd">        Returns:           </span>
<span class="sd">            :class:`GTI`: The new GTI object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gtis</span> <span class="o">=</span> <span class="p">[</span><span class="n">TimeRange</span><span class="p">(</span><span class="o">*</span><span class="n">one_gti</span><span class="p">)</span> <span class="k">for</span> <span class="n">one_gti</span> <span class="ow">in</span> <span class="n">gti_list</span><span class="p">]</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_gti</span> <span class="o">=</span> <span class="n">gtis</span>
        <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="GTI.from_boolean_mask"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.GTI.from_boolean_mask">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_boolean_mask</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new GTI object from a list of times and a Boolean mask</span>
<span class="sd">        Splits the boolean mask into segments of contiguous values and applies</span>
<span class="sd">        to array of times to create a GTI object.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            times (np.array): An array of times</span>
<span class="sd">            mask (np.array(dtype=bool)): The boolean array. Must be the same </span>
<span class="sd">                                         size as times.</span>
<span class="sd">        </span>
<span class="sd">        Returns:           </span>
<span class="sd">            :class:`GTI`: The new GTI object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># split a boolean mask array into segments based on True/False</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">mask</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">time_segs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
        <span class="n">mask_segs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>

        <span class="c1"># retrieve the start and stop times for the &quot;off&quot; intervals</span>
        <span class="n">segs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">numsegs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numsegs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mask_segs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">segs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">time_segs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_segs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="c1"># mark FIXME: null if mask is all True or all False</span>
        <span class="c1"># currently assuming that it must be all True</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">segs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">time_range</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_list</span><span class="p">(</span><span class="n">segs</span><span class="p">)</span></div>

<div class="viewcode-block" id="GTI.merge"><a class="viewcode-back" href="../../../api/api-data.html#gbm.data.primitives.GTI.merge">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">gti1</span><span class="p">,</span> <span class="n">gti2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new GTI object that is a merge of two existing GTI objects.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            gti1 (:class:`GTI`): A GTI to be merged</span>
<span class="sd">            gti2 (:class:`GTI`): A GTI to be merged</span>
<span class="sd">           </span>
<span class="sd">        Returns:</span>
<span class="sd">            :class:`GTI`: The new merged GTI object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time_list</span> <span class="o">=</span> <span class="n">gti1</span><span class="o">.</span><span class="n">as_list</span><span class="p">()</span>
        <span class="n">time_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">gti2</span><span class="o">.</span><span class="n">as_list</span><span class="p">())</span>
        <span class="n">time_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">time_list</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="o">*</span><span class="n">time_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="o">*</span><span class="n">interval</span><span class="p">)</span> <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">time_list</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">obj</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright .

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>